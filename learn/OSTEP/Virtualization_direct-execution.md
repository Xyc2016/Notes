# Direct Execution

## 有限直接执行

为什么不称为直接执行呢？因为直接执行是这样的：OS为运行一个程序做一些准备，比如载入内存。然后调用main函数，直到程序结束，然后OS释放内存，把进程移除进程列表。这种方式会带来一些问题：怎么防止程序作出我们不想让它作出的操作？OS怎么在程序运行的时候，切到另一个程序？也就是实现分时系统。
因为直接执行有以上的问题，所以需要有限直接执行。这样可以让OS掌握控制权。

## 问题1: 受限制的操作

程序通过系统调用来让OS帮助进行一些操作。为什么系统调用看起来就行是过程调用呢？系统调用是一类特殊的过程调用。系统调用里面有陷阱指令。

程序如何执行受限制的操作呢？一种方法是：直接让任何进程执行任何操作。但是这样，所有的保护措施都失效了。
所以，我们的方法是引入一种新的模式：用户模式。用户模式下的代码是受限的。

与用户模式相对应的是内核模式。这种模式下，代码可以做任意的操作。，执行任意的受限指令。

进程通过系统调用执行特权操作。系统调用允许内核暴露关键的功能给用户程序。这些功能包括访问文件系统，创建进程，等。

程序通过执行一个特殊的陷阱指令，来进行系统调用。这个指令会提升权限到系统模式，然后做需要的工作。然后之前从陷阱中返回的指令，回到用户模式。

陷阱表是在内核在启动的时候放置的。机器启动时在内核模式。OS做的第一件事，就是告诉硬件，一个确定的异常事件发生时，应该运行什么代码。比如硬盘中断时应该做什么；当键盘中断发生，活动当进程进行了系统调用。OS告诉硬件，这些陷阱处理程序的位置。硬件会记住这些位置，直到下一次重启。

每个系统调用会对应一个数字。用户代码负责把需要的系统调用数字房贷寄存器或者栈上的一个指定的地方。OS确认这个数字是合法的之后才会执行相应的代码。这是一种保护。用户代码不能直接指定一个地址，而是只能通过数字来请求服务。

## 问题2: 进程之前的切换

OS能切换进程的关键，在于重获CPU的控制权。

### 一种协作方式：等待系统调用

这种方式下，OS信任进程。OS会假设，进程在运行太长时间之后，会让出CPU。这种方式中，进程一般在进行系统调用的时候让CPU。这种系统，经常包含一种“让出”系统调用，这种系统调用什么也不做，只是把控制权让给OS，这样OS可以运行其它进程。

应用程序在做出非法的操作时，也会把控制交给OS。比如除以0时，会生成到OS的陷阱。OS会拿到CPU的控制权，kill掉这个进程。

这里有一个问题：一个程序陷入的无限循环，而且不进程系统调用。这时OS怎么做呢？

### 一种非协作式方式: OS掌握控制权

通过设置计时器，让计时器在每运行多少毫秒之后，抛出一个中断。当中断到来时，当前运行的进程被暂停了，运行预先设置好的中断handler。此时，OS重获CPU的控制权。此时可以做OS想做的事。
在启动时，OS必须启动计时器。

### 保存和恢复上下文

